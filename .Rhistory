rutaCiclos = "/home/mirt/Varios y Utilidades/Solicitudes Ricardo/Ciclos/"
rutaComparaciones = "/home/mirt/Varios y Utilidades/Solicitudes Ricardo/ComparacionesGrad/"
items = c(10,50,100)
inds = c(1000,5000,10000)
replica = c(1,2)
names = c("Min.","1st Qu.","Median","Mean","3rd Qu.","Max.")
for(i in 1:length(items)){
for(k in 1:length(replica)){
matSal = c()
ciclos = as.matrix(read.table(paste(rutaCiclos,"Test_",items[i],"_",k,"_",inds[i],".csv",sep = ""),header = T))[1,1]
for(j in 1:ciclos){
gradM = as.matrix(read.table(paste(rutaGradM,"Test_",items[i],"_",k,"_",inds[i],"_",j,".csv",sep = ""),header = T))[,1]
gradS = as.matrix(read.table(paste(rutaGradS,"Test_",items[i],"_",k,"_",inds[i],"_",j,".csv",sep = "")))[,1]
n = length(gradM)
m = length(gradS)
posA = seq(from = 1,to = n,by = 3)
posD = seq(from = 2,to = n,by = 3)
posC = seq(from = 3,to = n,by = 3)
gradM2 = gradM[c(posA,posD,posC)]
matSal = rbind(matSal,summary(abs(gradM2 - gradS)))
}
colnames(matSal) <-names
rownames(matSal) <-paste("Ciclo: ",1:ciclos)
#read.table(paste(rutaCiclos,"Test_",items[i],"_",k,"_",inds[i],".csv",sep = ""),header = T))
write.csv(matSal,paste(rutaComparaciones,"Test_",items[i],"_",k,"_",inds[i],".csv",sep = ""))
}
}
#rm(list = ls())
library(mirt)
#Funciona con a,b,c
M3PL <- function(zeta,theta){
P <- zeta[3] + (1-zeta[3])/(1+exp(-1.0*zeta[1]*(theta-zeta[2])))
}
zitaSicsToFitMirt = function(fit,zitaSics){
for(i in 1:nrow(zitaSics)){
fit@pars[[i]]@par = c(zitaSics[i,],999.0000000)
}
fit
}
fitToMat = function(fit){
conv = unlist(coef(fit))
conv = conv[1:(length(conv)-2)]
conv = matrix(data=conv,ncol=4,byrow=T)
conv = conv[,c(1,2,3)]
conv[,2] = - conv[,2] / conv[,1]
colnames(conv) <- c("a","b","c")
conv
}
indexPat = function(data,pats){
comprimData = apply(data,MARGIN=1,FUN=paste,collapse="/")
comprimPats = apply(pats[,1:ncol(data)],MARGIN=1,FUN=paste,collapse="/")
index = lapply(comprimPats,FUN = function(x) {which(x == comprimData)})
index
}
patrones = function(datos){
items = ncol(datos)
comprim = apply(datos,MARGIN=1,FUN=paste,collapse="/")
freq = table(comprim)
pats = names(freq)
freq = as.vector(freq)
pats = as.numeric(unlist(lapply(pats,FUN=strsplit,split="/")))
pats = matrix(pats,ncol=items,byrow=T)
pats = cbind(pats,freq)
pats
}
evaluateLL = function(data,zita,thetaPat){
pats = patrones(data)
index = indexPat(data,pats)
thetaExpand = numeric(nrow(data))
for(mm in 1:nrow(thetaPat)){
thetaExpand[index[[mm]]] = thetaPat[mm,ncol(data) +1]
}
MatrixP = apply(zita,1,M3PL,thetaExpand)
#Matriz para la suma de la logverosimilitud
MatrixPSum = matrix(0,nrow = nrow(MatrixP),ncol = ncol(MatrixP))
MatrixPSum[data == 1] = log(MatrixP[data == 1])
MatrixPSum[data == 0] = log(1 - MatrixP[data == 0])
LLMirtEAP = sum(MatrixPSum)
LLMirtEAP
}
#data = expand.table(LSAT7)
data = read.table("file:///home/mirt/Comparaciones_Montenegro/3PL/Datasets/Test_10_6_1000.csv",header = T)
fit = mirt(data=data,model = 1,itemtype = "3PL")
#EAPMM
#el objeto fit tiene internamente d y c trans sin embarfo fitToMat retorna b y c para evaluar la LL
zitaM = fitToMat(fit)
thetaPatM = fscores(fit,method = "EAP",verbose = FALSE)
LLEAPMM = evaluateLL(data = data,zita = zitaM,thetaPat = thetaPatM)
#EAPSM
est = estimacion.Newton(data)
zitaSics2 = zitaSics = est$zita
zitaSics2[,3] = qlogis(zitaSics2[,3])
zitaSics[,2] = -zitaSics[,2] / zitaSics[,1]
fitS = zitaSicsToFitMirt(fit = fit,zitaSics = zitaSics2)
thetaPatS = fscores(fitS,method = "EAP",verbose = FALSE)
LLEAPSM = evaluateLL(data = data,zita = zitaSics,thetaPat = thetaPatS)
#MAPMM
zitaM = fitToMat(fit)
thetaPatM = fscores(fit,method = "MAP",verbose = FALSE)
LLMAPMM = evaluateLL(data = data,zita = zitaM,thetaPat = thetaPatM)
#MAPSM
fitS = zitaSicsToFitMirt(fit = fit,zitaSics = zitaSics2)
thetaPatS = fscores(fitS,method = "MAP",verbose = FALSE)
LLMAPSM = evaluateLL(data = data,zita = zitaSics,thetaPat = thetaPatS)
rm(list = ls(all = TRUE))
library(mirt)
library(Matrix)
library(numDeriv)
#-fopenmp
setwd("/home/mirt/Git/GrupoSICS/dev/SICSRepositoryR/")
system("PKG_CPPFLAGS=`Rscript -e 'Rcpp:::CxxFlags()'` PKG_LIBS=`Rscript -e 'Rcpp:::LdFlags()'` R CMD SHLIB  pasoe3.cpp")
system("PKG_CPPFLAGS=`Rscript -e 'Rcpp:::CxxFlags()'` PKG_LIBS=`Rscript -e 'Rcpp:::LdFlags()'` R CMD SHLIB  pasom3.cpp")
dyn.load("pasoe3.so")
dyn.load("pasom3.so")
###########
# PRUEBAS #
###########
D = 1
##################################################
# 3.Funcion para inicializar valores con Andrade #
##################################################
start.andrade = function(datos){
I = ncol(datos)
P = nrow(datos)
m = 5
#scores
T = apply(datos,1,sum)
#correlacion biserial
corr.bis = rep(NA,I)
for(i in 1:I){
corr.bis[i]  = cor(datos[,i],T,method="pearson")
}
#a inicial
a.ini = sqrt(corr.bis^2/(1-(corr.bis^2)))
#proporcion de aciertos
pi = as.vector(apply(datos,2,sum) / P)
#a inicial
b.ini = -(qnorm(pi) / corr.bis)
#b inicial
c.ini = 1 / rep(m,I)
ini.andrade = matrix(c(a.ini,b.ini,c.ini),ncol=3)
colnames(ini.andrade) = c("a","b","c")
ini.andrade
}
#función de puntos de cuadratura y pesos
library(statmod)
Cuad = gauss.quad(n=41,"hermite")
pt.cuad = Cuad[[1]] * sqrt(2)
pt.cuad = - (pt.cuad)
#pt.cuad
w.cuad = Cuad[[2]]  /  sqrt(pi)
pt.cuad = read.table("/home/mirt/Trabajo IRT/Algoritmo SICS/PWcuad.csv",dec=".",sep = " ",header = T)
w.cuad = pt.cuad[,2]
pt.cuad = pt.cuad[,1]
#Valores Iniciales Andrade
#and = t(start.andrade(datos))
#and[2,] = -and[2,] * and[1,]
#and[3,] = qlogis(and[3,])
#valores iniciales MIRT
inicio.mirt = function(datos){
ini.mirt = mirt(data=datos,model=1,itemtype="3PL",pars="values")
ini.mirt = ini.mirt$value
ini.mirt = ini.mirt[1:(length(ini.mirt) -2)]
ini.mirt = t(matrix(ini.mirt,ncol=4,byrow=T)[,c(1,2,3)])
ini.mirt[3,] = qlogis(ini.mirt[3,])
and = ini.mirt
and
}
patrones = function(datos){
items = ncol(datos)
comprim = apply(datos,MARGIN=1,FUN=paste,collapse="/")
freq = table(comprim)
pats = names(freq)
freq = as.vector(freq)
pats = as.numeric(unlist(lapply(pats,FUN=strsplit,split="/")))
pats = matrix(pats,ncol=items,byrow=T)
pats = cbind(pats,freq)
pats
}
#Probabilidad
gg = function(a,d, cp,  theta){
exp(cp)/(1+exp(cp))+ (1-(exp(cp)/(1+exp(cp))))*(1 + exp(-D*(a*theta+ d)))^(-1)
}
#Log verosimilitud
LL = function(zita.vec,R,fvec,pt.cuad,nitems){
suma = 0
for(k in 1:41){
for(i in 1:nitems){
rki = R[k,i]
fki = fvec[k]
a = zita.vec[i]
d = zita.vec[nitems + i]
c = zita.vec[2*nitems + i]
pki = gg(a=a,d=d,cp=c,theta=pt.cuad[k])
qki = 1 - pki
suma = suma + (rki*log(pki)+(fki-rki)*
log(qki))
}
}
-suma
}
unSumR = function(zita.vec,R,fvec,pt.cuad,i){
suma = 0
for(k in 1:41){
rki = R[k,i]
fki = fvec[k]
a = zita.vec[i]
d = zita.vec[nitems + i]
c = zita.vec[2*nitems + i]
pki = gg(a=a,d=d,cp=c,theta=pt.cuad[k])
qki = 1 - pki
suma = suma + (rki*log(pki)+(fki-rki)*
log(qki))
}
-suma
}
LL2 = function(zita.vec,R,fvec,pt.cuad,nitems,and){
.Call("Loglik",zita.vec,R,fvec,pt.cuad)
}
gradLoglik = function(zita.vec,R,fvec,pt.cuad,nitems,and){
.Call("grad",zita.vec,R,fvec,pt.cuad)
}
unSum = function(zita.vec,R,fvec,pt.cuad,nitems,and,i){
.Call("unSumando",zita.vec,R,fvec,pt.cuad,i-1)
}
inicio = Sys.time()
###################
# Algoritmos SICS #
###################
estimacion.Newton = function(datos){
and = inicio.mirt(datos)
and.copia = and
pats = patrones(datos)
npats = nrow(pats)
nitems = ncol(pats) - 1
zita.ant = zita = and
seguir = TRUE
mm = 0
contadorNear = 0
while(seguir){
inicio.ciclo = Sys.time()
mm = mm +1
##########
# Paso E #
##########
#inicioE = Sys.time()
RyF=.Call("calculoRF2",and,pt.cuad,w.cuad,pats)
#te = Sys.time() - inicioE
#print("*********Tiempo E")
#print(te)
R = RyF$R
fvec = RyF$fvec
##########
# Paso M #
##########
print("Entra a optim")
zita.vec = as.vector(t(zita))
#opt = optim(par=zita.vec,fn=LL2,gr=gradLoglik,method= "BFGS",R=R,fvec=fvec,pt.cuad=pt.cuad,nitems=nitems,and=and,control=list(maxit=20),hessian = T)
for(i in 1:nitems){
opt2 = optim(par=zita.vec,fn=unSum,method= "BFGS",R=R,fvec=fvec,pt.cuad=pt.cuad,nitems=nitems,and=and,i=i,control=list(maxit=20),hessian = T)
zita.vec = opt2$par
}
#print(opt$par)
#print(zita.vec)
contadorNear = contadorNear + 1
zita = matrix(zita.vec,ncol=nitems,byrow=T)
hess = opt2$hessian
zita[1,] = ifelse(abs(zita[1,]) > 10, and[1,], zita[1,])
zita[2,] = ifelse(abs(zita[2,]) > 40, and[2,], zita[2,])
zita[3,] = ifelse(abs(zita[3,]) > 600, and[3,], zita[3,])
##Imprime salidas
#print(mean(abs((zita - zita.ant)/zita.ant)))
print(paste("Fin ciclo: ", mm, " Convergencia: ", max(abs((zita - zita.ant)))," Tiempo Ciclo: ",Sys.time() - inicio.ciclo))
if(max(abs((zita - zita.ant))) < 10^(-4)){seguir = FALSE}
and = zita.ant = zita
if(mm > 200){
print(paste("El algoritmo superó los ",mm - 1," ciclos",sep=""))
break()
#stop(paste("El algoritmo superó los ",mm - 1," ciclos",sep=""))
}
} #fin while
zita[3,] = plogis(zita[3,])
zita = t(zita)
list(zita=zita,contadorNear=contadorNear,ciclos = mm,pats = pats,hess = hess)
}
gcc = NULL
#sink("/home/mirt/Trabajo IRT/Algoritmo SICS/SalidaAUX.txt")
#rm(list = ls())
library(mirt)
#Funciona con a,b,c
M3PL <- function(zeta,theta){
P <- zeta[3] + (1-zeta[3])/(1+exp(-1.0*zeta[1]*(theta-zeta[2])))
}
zitaSicsToFitMirt = function(fit,zitaSics){
for(i in 1:nrow(zitaSics)){
fit@pars[[i]]@par = c(zitaSics[i,],999.0000000)
}
fit
}
fitToMat = function(fit){
conv = unlist(coef(fit))
conv = conv[1:(length(conv)-2)]
conv = matrix(data=conv,ncol=4,byrow=T)
conv = conv[,c(1,2,3)]
conv[,2] = - conv[,2] / conv[,1]
colnames(conv) <- c("a","b","c")
conv
}
indexPat = function(data,pats){
comprimData = apply(data,MARGIN=1,FUN=paste,collapse="/")
comprimPats = apply(pats[,1:ncol(data)],MARGIN=1,FUN=paste,collapse="/")
index = lapply(comprimPats,FUN = function(x) {which(x == comprimData)})
index
}
patrones = function(datos){
items = ncol(datos)
comprim = apply(datos,MARGIN=1,FUN=paste,collapse="/")
freq = table(comprim)
pats = names(freq)
freq = as.vector(freq)
pats = as.numeric(unlist(lapply(pats,FUN=strsplit,split="/")))
pats = matrix(pats,ncol=items,byrow=T)
pats = cbind(pats,freq)
pats
}
evaluateLL = function(data,zita,thetaPat){
pats = patrones(data)
index = indexPat(data,pats)
thetaExpand = numeric(nrow(data))
for(mm in 1:nrow(thetaPat)){
thetaExpand[index[[mm]]] = thetaPat[mm,ncol(data) +1]
}
MatrixP = apply(zita,1,M3PL,thetaExpand)
#Matriz para la suma de la logverosimilitud
MatrixPSum = matrix(0,nrow = nrow(MatrixP),ncol = ncol(MatrixP))
MatrixPSum[data == 1] = log(MatrixP[data == 1])
MatrixPSum[data == 0] = log(1 - MatrixP[data == 0])
LLMirtEAP = sum(MatrixPSum)
LLMirtEAP
}
#data = expand.table(LSAT7)
data = read.table("file:///home/mirt/Comparaciones_Montenegro/3PL/Datasets/Test_10_6_1000.csv",header = T)
fit = mirt(data=data,model = 1,itemtype = "3PL")
#EAPMM
#el objeto fit tiene internamente d y c trans sin embarfo fitToMat retorna b y c para evaluar la LL
zitaM = fitToMat(fit)
thetaPatM = fscores(fit,method = "EAP",verbose = FALSE)
LLEAPMM = evaluateLL(data = data,zita = zitaM,thetaPat = thetaPatM)
#EAPSM
est = estimacion.Newton(data)
#rm(list = ls())
library(mirt)
#Funciona con a,b,c
M3PL <- function(zeta,theta){
P <- zeta[3] + (1-zeta[3])/(1+exp(-1.0*zeta[1]*(theta-zeta[2])))
}
zitaSicsToFitMirt = function(fit,zitaSics){
for(i in 1:nrow(zitaSics)){
fit@pars[[i]]@par = c(zitaSics[i,],999.0000000)
}
fit
}
fitToMat = function(fit){
conv = unlist(coef(fit))
conv = conv[1:(length(conv)-2)]
conv = matrix(data=conv,ncol=4,byrow=T)
conv = conv[,c(1,2,3)]
conv[,2] = - conv[,2] / conv[,1]
colnames(conv) <- c("a","b","c")
conv
}
indexPat = function(data,pats){
comprimData = apply(data,MARGIN=1,FUN=paste,collapse="/")
comprimPats = apply(pats[,1:ncol(data)],MARGIN=1,FUN=paste,collapse="/")
index = lapply(comprimPats,FUN = function(x) {which(x == comprimData)})
index
}
patrones = function(datos){
items = ncol(datos)
comprim = apply(datos,MARGIN=1,FUN=paste,collapse="/")
freq = table(comprim)
pats = names(freq)
freq = as.vector(freq)
pats = as.numeric(unlist(lapply(pats,FUN=strsplit,split="/")))
pats = matrix(pats,ncol=items,byrow=T)
pats = cbind(pats,freq)
pats
}
evaluateLL = function(data,zita,thetaPat){
pats = patrones(data)
index = indexPat(data,pats)
thetaExpand = numeric(nrow(data))
for(mm in 1:nrow(thetaPat)){
thetaExpand[index[[mm]]] = thetaPat[mm,ncol(data) +1]
}
MatrixP = apply(zita,1,M3PL,thetaExpand)
#Matriz para la suma de la logverosimilitud
MatrixPSum = matrix(0,nrow = nrow(MatrixP),ncol = ncol(MatrixP))
MatrixPSum[data == 1] = log(MatrixP[data == 1])
MatrixPSum[data == 0] = log(1 - MatrixP[data == 0])
LLMirtEAP = sum(MatrixPSum)
LLMirtEAP
}
#data = expand.table(LSAT7)
data = read.table("file:///home/mirt/Comparaciones_Montenegro/3PL/Datasets/Test_10_6_1000.csv",header = T)
inicio = Sys.time()
fit = mirt(data=data,model = 1,itemtype = "3PL")
Sys.time() - inicio
#EAPMM
#el objeto fit tiene internamente d y c trans sin embarfo fitToMat retorna b y c para evaluar la LL
zitaM = fitToMat(fit)
thetaPatM = fscores(fit,method = "EAP",verbose = FALSE)
LLEAPMM = evaluateLL(data = data,zita = zitaM,thetaPat = thetaPatM)
#EAPSM
inicio = Sys.time()
est = estimacion.Newton(data)
Sys.time() - inicio
zitaSics2 = zitaSics = est$zita
zitaSics2[,3] = qlogis(zitaSics2[,3])
zitaSics[,2] = -zitaSics[,2] / zitaSics[,1]
fitS = zitaSicsToFitMirt(fit = fit,zitaSics = zitaSics2)
thetaPatS = fscores(fitS,method = "EAP",verbose = FALSE)
LLEAPSM = evaluateLL(data = data,zita = zitaSics,thetaPat = thetaPatS)
#MAPMM
zitaM = fitToMat(fit)
thetaPatM = fscores(fit,method = "MAP",verbose = FALSE)
LLMAPMM = evaluateLL(data = data,zita = zitaM,thetaPat = thetaPatM)
#MAPSM
fitS = zitaSicsToFitMirt(fit = fit,zitaSics = zitaSics2)
thetaPatS = fscores(fitS,method = "MAP",verbose = FALSE)
LLMAPSM = evaluateLL(data = data,zita = zitaSics,thetaPat = thetaPatS)
#rm(list = ls())
library(mirt)
#Funciona con a,b,c
M3PL <- function(zeta,theta){
P <- zeta[3] + (1-zeta[3])/(1+exp(-1.0*zeta[1]*(theta-zeta[2])))
}
zitaSicsToFitMirt = function(fit,zitaSics){
for(i in 1:nrow(zitaSics)){
fit@pars[[i]]@par = c(zitaSics[i,],999.0000000)
}
fit
}
fitToMat = function(fit){
conv = unlist(coef(fit))
conv = conv[1:(length(conv)-2)]
conv = matrix(data=conv,ncol=4,byrow=T)
conv = conv[,c(1,2,3)]
conv[,2] = - conv[,2] / conv[,1]
colnames(conv) <- c("a","b","c")
conv
}
indexPat = function(data,pats){
comprimData = apply(data,MARGIN=1,FUN=paste,collapse="/")
comprimPats = apply(pats[,1:ncol(data)],MARGIN=1,FUN=paste,collapse="/")
index = lapply(comprimPats,FUN = function(x) {which(x == comprimData)})
index
}
patrones = function(datos){
items = ncol(datos)
comprim = apply(datos,MARGIN=1,FUN=paste,collapse="/")
freq = table(comprim)
pats = names(freq)
freq = as.vector(freq)
pats = as.numeric(unlist(lapply(pats,FUN=strsplit,split="/")))
pats = matrix(pats,ncol=items,byrow=T)
pats = cbind(pats,freq)
pats
}
evaluateLL = function(data,zita,thetaPat){
pats = patrones(data)
index = indexPat(data,pats)
thetaExpand = numeric(nrow(data))
for(mm in 1:nrow(thetaPat)){
thetaExpand[index[[mm]]] = thetaPat[mm,ncol(data) +1]
}
MatrixP = apply(zita,1,M3PL,thetaExpand)
#Matriz para la suma de la logverosimilitud
MatrixPSum = matrix(0,nrow = nrow(MatrixP),ncol = ncol(MatrixP))
MatrixPSum[data == 1] = log(MatrixP[data == 1])
MatrixPSum[data == 0] = log(1 - MatrixP[data == 0])
LLMirtEAP = sum(MatrixPSum)
LLMirtEAP
}
#data = expand.table(LSAT7)
data = read.table("file:///home/mirt/Comparaciones_Montenegro/3PL/Datasets/Test_10_4_1000.csv",header = T)
inicio = Sys.time()
fit = mirt(data=data,model = 1,itemtype = "3PL")
Sys.time() - inicio
#EAPMM
#el objeto fit tiene internamente d y c trans sin embarfo fitToMat retorna b y c para evaluar la LL
zitaM = fitToMat(fit)
thetaPatM = fscores(fit,method = "EAP",verbose = FALSE)
LLEAPMM = evaluateLL(data = data,zita = zitaM,thetaPat = thetaPatM)
#EAPSM
inicio = Sys.time()
est = estimacion.Newton(data)
Sys.time() - inicio
zitaSics2 = zitaSics = est$zita
zitaSics2[,3] = qlogis(zitaSics2[,3])
zitaSics[,2] = -zitaSics[,2] / zitaSics[,1]
fitS = zitaSicsToFitMirt(fit = fit,zitaSics = zitaSics2)
thetaPatS = fscores(fitS,method = "EAP",verbose = FALSE)
LLEAPSM = evaluateLL(data = data,zita = zitaSics,thetaPat = thetaPatS)
#MAPMM
zitaM = fitToMat(fit)
thetaPatM = fscores(fit,method = "MAP",verbose = FALSE)
LLMAPMM = evaluateLL(data = data,zita = zitaM,thetaPat = thetaPatM)
#MAPSM
fitS = zitaSicsToFitMirt(fit = fit,zitaSics = zitaSics2)
thetaPatS = fscores(fitS,method = "MAP",verbose = FALSE)
LLMAPSM = evaluateLL(data = data,zita = zitaSics,thetaPat = thetaPatS)
