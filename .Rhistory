generarValoresIniciales = function ( Datos ) {
ini.mirt = mirt(data=Datos,model=1,itemtype="3PL",pars="values")
ini.mirt = ini.mirt$value
ini.mirt = ini.mirt[1:(length(ini.mirt)-2)]
ini.mirt = matrix(ini.mirt,ncol=4,byrow=T)
ini.mirt = ini.mirt[,c(1,2,3)]
ini.mirt[,2] = - ini.mirt[,2] / ini.mirt[,1]
colnames(ini.mirt) <- c("a","b","c")
ini.mirt
}
exportarValConvergencia = function(fit,rutaConvergencia,j,i,k,itemsElim){
conv = unlist(coef(fit))
conv = conv[1:(length(conv)-2)]
conv = matrix(data=conv,ncol=4,byrow=T)
conv = conv[,c(1,2,3)]
conv[,2] = - conv[,2] / conv[,1]
colnames(conv) <- c("a","b","c")
#Las estimaciones de los items perfectos o nulos
#las llena con -99
if(itemsElim[1] !=  0){
for(l in 1:length(itemsElim)){
row = itemsElim[l]
if(row == 1){
conv = rbind(rep(-99,3),conv)
}else{
conv = rbind(conv[1:row-1,],rep(-99,3),conv[-(1:row-1),])
}
}
}
nombre.arch = paste("Test_",items[k],"_",j,"_",inds[i],".csv",sep="")
nombre.arch = paste(rutaConvergencia,nombre.arch,sep="")
write.table(x=conv,file=nombre.arch,row.names=F)
}
GenerarTodo = function(items,inds,nciclos,type,rutaPrin){
#Ruta Salidas
rutaDatasets = paste(rutaPrin,"Datasets/",sep = "")
rutaPobl = paste(rutaPrin,"ZitaPob/", sep ="")
rutaHabilid = paste(rutaPrin,"ThetasPob/", sep = "")
rutaIniciales = paste(rutaPrin,"InitialValues/",sep = "")
rutaTiempo = paste(rutaPrin,"TiempoMirt/",sep = "")
rutaConvergencia = paste(rutaPrin,"ConvergenceMirt/",sep = "")
rutaObjetoMirt = paste(rutaPrin,"ObjetoFitMirt/", sep = "")
rutaTiempoGlobal = paste(rutaPrin,"TiempoMirtGlob/", sep = "")
rutaCiclos = paste(rutaPrin,"NcyclesMirt/", sep = "")
rutaPerfec = paste(rutaPrin,"ItemsIndsPerfectos/", sep = "")
rutaHabEAP = paste(rutaPrin,"HabilidadMirtEAP/", sep = "")
rutaHabMAP = paste(rutaPrin,"HabilidadMirtMAP/", sep = "")
rutaTiempoEAP = paste(rutaPrin,"TiempoMirtEAP/", sep = "")
rutaTiempoMAP = paste(rutaPrin,"TiempoMirtMAP/", sep = "")
rutaDataNoTrunc = paste(rutaPrin,"DatasetsSinTrunc/", sep = "")
for(k in 1:length(items)){
for(i in 1:length(inds)){
test = generarTest(N=inds[i],items=items[k],nciclos,type,rutaDataNoTrunc)
tiempoGlob = list()
#Exporta thetas
nombre.arch = paste("Test_",items[k],"_",inds[i],".csv",sep="")
nombre.arch = paste(rutaHabilid,nombre.arch,sep="")
write.table(x=test[[3]],file=nombre.arch,row.names=F)
#Exporta parametros que generan test
nombre.arch = paste("Test_",items[k],"_",inds[i],".csv",sep="")
nombre.arch = paste(rutaPobl,nombre.arch,sep="")
write.table(x=test[[2]],file=nombre.arch,row.names=F)
for(j in 1:nciclos){
#Captura ciclos de mirt
cyclesMirt <<- 0
print(paste("Items_",items[k],"_dataset_",j,"_inds_",inds[i],sep=""))
#Tiempo demorado
tiempo = 0
Datos = test[[1]][[j]]
indsElim = test[[4]][[j]]
itemsElim = test[[5]][[j]]
#El tratamiento de los scores perfectos y nulos se hizo en la generación del dataset
#Exporta Datasets truncados (sin items ni scores perf ni nulos)
nombre.arch = paste("Test_",items[k],"_",j,"_",inds[i],".csv",sep="")
nombre.arch = paste(rutaDatasets,nombre.arch,sep="")
write.table(x=Datos,file=nombre.arch,row.names=F)
#Exporta item y scores perfectos
nombre.arch = paste("Test_",items[k],"_",j,"_",inds[i],"_inds.csv",sep="")
nombre.arch = paste(rutaPerfec,nombre.arch,sep="")
write.table(x=indsElim,file=nombre.arch,row.names=F)
nombre.arch = paste("Test_",items[k],"_",j,"_",inds[i],"_items.csv",sep="")
nombre.arch = paste(rutaPerfec,nombre.arch,sep="")
write.table(x=itemsElim,file=nombre.arch,row.names=F)
#Valores iniciales
ini.mirt = generarValoresIniciales(Datos)
nombre.arch = paste("Test_",items[k],"_",j,"_",inds[i],".csv",sep="")
nombre.arch = paste(rutaIniciales,nombre.arch,sep="")
write.table(x=ini.mirt,file=nombre.arch,row.names=F)
#Booleano que controla errores
error = F
result <- tryCatch({
inicio = Sys.time()
fit = mirt(data=Datos,model=1,itemtype="3PL",technical = list(NCYCLES = 1000))
tiempo = difftime(time2=inicio,time1=Sys.time(),units="secs")
tiempoGlob = append(tiempoGlob,tiempo)
}, warning = function(war) {}, error = function(err) {
#Si ocurre un error
error <<- T
print("Ocurrió un error con la estimación.")
}, finally = {
#print("Passing to next");
})
#Si ocurrió un error se descarta el dataset y se hace otro ciclo
if(error){
j = j - 1
}else{
#exporta el tiempo
nombre.arch = paste("Test_",items[k],"_",j,"_",inds[i],".csv",sep="")
nombre.arch = paste(rutaTiempo,nombre.arch,sep="")
write.table(x=toString(tiempo),file=nombre.arch,row.names=F)
#Exporta ciclos EM usados por mirt
nombre.arch = paste("Test_",items[k],"_",j,"_",inds[i],".csv",sep="")
nombre.arch = paste(rutaCiclos,nombre.arch,sep="")
write.table(x=toString(cyclesMirt),file=nombre.arch,row.names=F)
#Exporta convergencia
exportarValConvergencia(fit,rutaConvergencia,j,i,k,itemsElim)
#exportarValConvergencia(fit,rutaConvergencia,j,i,k,c(2,9))
#Exporta objeto fit mirt
nombre.arch = paste("Test_",items[k],"_",j,"_",inds[i],".RData",sep="")
save(fit,file = paste(rutaObjetoMirt,nombre.arch,sep = ""))
#Calcula scores
inicio = Sys.time()
scoresEAP=fscores(fit,method = "EAP",verbose = F)
tiempoEAP = difftime(time2=inicio,time1=Sys.time(),units="secs")
inicio = Sys.time()
scoresMAP=fscores(fit,method = "MAP",verbose = F)
tiempoMAP = difftime(time2=inicio,time1=Sys.time(),units="secs")
#Exporta scores
nombre.arch = paste("Test_",items[k],"_",j,"_",inds[i],".csv",sep="")
nombre.arch = paste(rutaHabEAP,nombre.arch,sep="")
write.table(x=scoresEAP,file=nombre.arch,row.names=F)
nombre.arch = paste("Test_",items[k],"_",j,"_",inds[i],".csv",sep="")
nombre.arch = paste(rutaHabMAP,nombre.arch,sep="")
write.table(x=scoresMAP,file=nombre.arch,row.names=F)
#Exporta tiempo scores
rutaTiempoEAP
nombre.arch = paste("Test_",items[k],"_",j,"_",inds[i],".csv",sep="")
nombre.arch = paste(rutaTiempoEAP,nombre.arch,sep="")
write.table(x=tiempoEAP,file=nombre.arch,row.names=F)
nombre.arch = paste("Test_",items[k],"_",j,"_",inds[i],".csv",sep="")
nombre.arch = paste(rutaTiempoMAP,nombre.arch,sep="")
write.table(x=tiempoMAP,file=nombre.arch,row.names=F)
}
} #fin for replicas
#Exporta tiempo global usado solo por la estimación replicas
tiempoGlobExport = sum(unlist(tiempoGlob))
nombre.arch = paste("Test_",items[k],"_",inds[i],".csv",sep="")
nombre.arch = paste(rutaTiempoGlobal,nombre.arch,sep="")
write.table(x=toString(tiempoGlobExport),file=nombre.arch,row.names=F)
}
}
}
#Generacion
#Semilla para los números aleatorios
set.seed(200)
#Ruta principal
rutaPrin = "/home/mirt/Validaciones_Modelos_Principales/Bloque 1/3PL/"
setwd(rutaPrin)
items = c(10)
inds = c(1000)
nciclos = 5
#sink("file:///home/mirt/Validaciones_Modelos_Principales/salida.txt")
inicio = Sys.time()
GenerarTodo(items,inds,nciclos,"3PL",rutaPrin)
library(mirt)
data = read.table(file = "file:///home/mirt/Validaciones_Modelos_Principales/Bloque 1/3PL/Datasets/Test_10_1_1000.csv" ,header = T,sep = " ")
pats = patrones(data)
rm(list = ls(all = TRUE))
library(mirt)
library(Matrix)
library(numDeriv)
#-fopenmp
setwd("/home/mirt/Git/GrupoSICS/dev/SICSRepositoryR/")
system("PKG_CPPFLAGS=`Rscript -e 'Rcpp:::CxxFlags()'` PKG_LIBS=`Rscript -e 'Rcpp:::LdFlags()'` R CMD SHLIB  pasoe3.cpp")
system("PKG_CPPFLAGS=`Rscript -e 'Rcpp:::CxxFlags()'` PKG_LIBS=`Rscript -e 'Rcpp:::LdFlags()'` R CMD SHLIB  pasom3.cpp")
dyn.load("pasoe3.so")
dyn.load("pasom3.so")
###########
# PRUEBAS #
###########
D = 1
##################################################
# 3.Funcion para inicializar valores con Andrade #
##################################################
start.andrade = function(datos){
I = ncol(datos)
P = nrow(datos)
m = 5
#scores
T = apply(datos,1,sum)
#correlacion biserial
corr.bis = rep(NA,I)
for(i in 1:I){
corr.bis[i]  = cor(datos[,i],T,method="pearson")
}
#a inicial
a.ini = sqrt(corr.bis^2/(1-(corr.bis^2)))
#proporcion de aciertos
pi = as.vector(apply(datos,2,sum) / P)
#a inicial
b.ini = -(qnorm(pi) / corr.bis)
#b inicial
c.ini = 1 / rep(m,I)
ini.andrade = matrix(c(a.ini,b.ini,c.ini),ncol=3)
colnames(ini.andrade) = c("a","b","c")
ini.andrade
}
#función de puntos de cuadratura y pesos
library(statmod)
Cuad = gauss.quad(n=41,"hermite")
pt.cuad = Cuad[[1]] * sqrt(2)
pt.cuad = - (pt.cuad)
#pt.cuad
w.cuad = Cuad[[2]]  /  sqrt(pi)
pt.cuad = read.table("/home/mirt/Trabajo IRT/Algoritmo SICS/PWcuad.csv",dec=".",sep = " ",header = T)
w.cuad = pt.cuad[,2]
pt.cuad = pt.cuad[,1]
#Valores Iniciales Andrade
#and = t(start.andrade(datos))
#and[2,] = -and[2,] * and[1,]
#and[3,] = qlogis(and[3,])
#valores iniciales MIRT
inicio.mirt = function(datos){
ini.mirt = mirt(data=datos,model=1,itemtype="3PL",pars="values")
ini.mirt = ini.mirt$value
ini.mirt = ini.mirt[1:(length(ini.mirt) -2)]
ini.mirt = t(matrix(ini.mirt,ncol=4,byrow=T)[,c(1,2,3)])
ini.mirt[3,] = qlogis(ini.mirt[3,])
and = ini.mirt
and
}
patrones = function(datos){
items = ncol(datos)
comprim = apply(datos,MARGIN=1,FUN=paste,collapse="/")
freq = table(comprim)
pats = names(freq)
freq = as.vector(freq)
pats = as.numeric(unlist(lapply(pats,FUN=strsplit,split="/")))
pats = matrix(pats,ncol=items,byrow=T)
pats = cbind(pats,freq)
pats
}
#Probabilidad
gg = function(a,d, cp,  theta){
exp(cp)/(1+exp(cp))+ (1-(exp(cp)/(1+exp(cp))))*(1 + exp(-D*(a*theta+ d)))^(-1)
}
#Log verosimilitud
LL = function(zita.vec,R,fvec,pt.cuad,nitems){
suma = 0
for(k in 1:41){
for(i in 1:nitems){
rki = R[k,i]
fki = fvec[k]
a = zita.vec[i]
d = zita.vec[nitems + i]
c = zita.vec[2*nitems + i]
pki = gg(a=a,d=d,cp=c,theta=pt.cuad[k])
qki = 1 - pki
suma = suma + (rki*log(pki)+(fki-rki)*
log(qki))
}
}
-suma
}
LL2 = function(zita.vec,R,fvec,pt.cuad,nitems,and){
.Call("Loglik",zita.vec,R,fvec,pt.cuad)
}
gradLoglik = function(zita.vec,R,fvec,pt.cuad,nitems,and){
.Call("grad",zita.vec,R,fvec,pt.cuad)
}
inicio = Sys.time()
###################
# Algoritmos SICS #
###################
estimacion.Newton = function(datos){
and = inicio.mirt(datos)
and.copia = and
pats = patrones(datos)
npats = nrow(pats)
nitems = ncol(pats) - 1
zita.ant = zita = and
seguir = TRUE
mm = 0
contadorNear = 0
while(seguir){
inicio.ciclo = Sys.time()
mm = mm +1
##########
# Paso E #
##########
#inicioE = Sys.time()
RyF=.Call("calculoRF2",and,pt.cuad,w.cuad,pats)
#te = Sys.time() - inicioE
#print("*********Tiempo E")
#print(te)
R = RyF$R
fvec = RyF$fvec
##########
# Paso M #
##########
print("Entra a optim")
zita.vec = as.vector(t(zita))
#opt = optim(par=zita.vec,fn=LL,method="BFGS",R=R,fvec=fvec,pt.cuad=pt.cuad,nitems = nitems,control=list(maxit=10))
opt = optim(par=zita.vec,fn=LL2,gr=gradLoglik,method= "BFGS",R=R,fvec=fvec,pt.cuad=pt.cuad,nitems=nitems,and=and,control=list(maxit=20),hessian = T)
#opt = optim(par=zita.vec,fn=LL2,method= "L-BFGS-B",R=R,fvec=fvec,pt.cuad=pt.cuad,nitems=nitems,and=and,control=list(maxit=10))
#,lower = c(rep(-10,10),rep(-40,10),rep(-600,10)),upper = c(rep(10,10),rep(40,10),rep(600,10)))
#opt = vmmin(fr=LL,x=zita.vec,R=R,fvec=fvec,pt.cuad=pt.cuad,nitems = nitems)
contadorNear = contadorNear + 1
zita = matrix(opt$par,ncol=nitems,byrow=T)
hess = opt$hessian
zita[1,] = ifelse(abs(zita[1,]) > 10, and[1,], zita[1,])
zita[2,] = ifelse(abs(zita[2,]) > 40, and[2,], zita[2,])
zita[3,] = ifelse(abs(zita[3,]) > 600, and[3,], zita[3,])
##Imprime salidas
#print(mean(abs((zita - zita.ant)/zita.ant)))
print(paste("Fin ciclo: ", mm, " Convergencia: ", max(abs((zita - zita.ant)))," Tiempo Ciclo: ",Sys.time() - inicio.ciclo))
if(max(abs((zita - zita.ant))) < 10^(-3)){seguir = FALSE}
and = zita.ant = zita
if(mm > 1000){
print(paste("El algoritmo superó los ",mm - 1," ciclos",sep=""))
break()
#stop(paste("El algoritmo superó los ",mm - 1," ciclos",sep=""))
}
} #fin while
zita[3,] = plogis(zita[3,])
zita = t(zita)
list(zita=zita,contadorNear=contadorNear,ciclos = mm,pats = pats,hess = hess)
}
gcc = NULL
#sink("/home/mirt/Trabajo IRT/Algoritmo SICS/SalidaAUX.txt")
library(mirt)
data = read.table(file = "file:///home/mirt/Validaciones_Modelos_Principales/Bloque 1/3PL/Datasets/Test_10_1_1000.csv" ,header = T,sep = " ")
pats = patrones(data)
patsSinFrec = pats[,-ncol(pats)]
View(pats)
pats = patrones(data)
patsSinFrec = pats[,-ncol(pats)]
and = start.andrade(data)
b.ini = and[,2]
b.ini
prob = function(theta, beta){
1 / (1 + exp(-(theta-beta)))
}
start.theta = function(datos){
score = rowSums(datos)
(score - mean(score)) / sd(score)
}
theta.ini = start.theta(data)
theta.ini
score = rowSums(data)
score
scoreUniq = unique(score)
scoreUniq
patsSinFrec
agrup = list()
agrup = list()
for(i in 1:length(scoreUniq)){
print(which(patsSinFrec[,ncol(patsSinFrec)] == scoreUniq[i]))
agrup = append(agrup,list(which(patsSinFrec[,ncol(patsSinFrec)] == scoreUniq[i])))
}
agrup
agrup[[1]]
scoreUniq = unique(score)
scoreUniq = unique(score)
score
score = rowSums(data)
score
scoreUniq = unique(score)
scoreUniq
scoreUniq = sort(unique(score))
scoreUniq
agrup = list()
agrup = list()
for(i in 1:length(scoreUniq)){
print(which(patsSinFrec[,ncol(patsSinFrec)] == scoreUniq[i]))
agrup = append(agrup,list(which(patsSinFrec[,ncol(patsSinFrec)] == scoreUniq[i])))
}
patsSinFrec[,ncol(patsSinFrec)]
pa
patsSinFrec
patsSinFrec = cbind(patsSinFrec,rowSums(patsSinFrec))
agrup = list()
for(i in 1:length(scoreUniq)){
print(which(patsSinFrec[,ncol(patsSinFrec)] == scoreUniq[i]))
agrup = append(agrup,list(which(patsSinFrec[,ncol(patsSinFrec)] == scoreUniq[i])))
}
agrup
agrup[[1]]
for(i in 1:length(agrup)){
inds = agrup[[i]]
}
for(i in 1:length(agrup)){
inds = agrup[[i]]
print(inds)
}
subMat = pats[inds,]
for(i in 1:length(agrup)){
inds = agrup[[i]]
print(inds)
subMat = pats[inds,]
}
subMat
b
theta.ini
b.ini
rep(b.ini,length(inds))
matrix(rep(b.ini,length(inds)),nrow= length(inds))
matrix(rep(b.ini,length(inds)),nrow= length(inds),byrow = T)
for(i in 1:length(agrup)){
inds = agrup[[i]]
n = length(inds)
subMat = pats[inds,]
matrix(rep(b.ini,n),nrow=n,byrow = T)
}
for(i in 1:length(agrup)){
inds = agrup[[i]]
n = length(inds)
subMat = pats[inds,]
matB = matrix(rep(b.ini,n),nrow=n,byrow = T)
print("--------------------------------")
print(subMat)
print(matB)
}
for(i in 1:length(agrup)){
inds = agrup[[i]]
n = length(inds)
subMat = pats[inds,]
matB = matrix(rep(b.ini,n),nrow=n,byrow = T)
print("--------------------------------")
print(subMat)
print(matB)
}
for(i in 1:length(agrup)){
inds = agrup[[i]]
n = length(inds)
subMat = pats[inds,][,-ncol(pats)]
matB = matrix(rep(b.ini,n),nrow=n,byrow = T)
print("--------------------------------")
print(subMat)
print(matB)
}
library(mirt)
data = read.table(file = "file:///home/mirt/Validaciones_Modelos_Principales/Bloque 1/3PL/Datasets/Test_10_1_1000.csv" ,header = T,sep = " ")
pats = patrones(data)
patsSinFrec = pats[,-ncol(pats)]
and = start.andrade(data)
b.ini = and[,2]
b.ini
prob = function(theta, beta){
1 / (1 + exp(-(theta-beta)))
}
start.theta = function(datos){
score = rowSums(datos)
(score - mean(score)) / sd(score)
}
theta.ini = start.theta(data)
theta.ini
score = rowSums(data)
score
scoreUniq = sort(unique(score))
scoreUniq
patsSinFrec = cbind(patsSinFrec,rowSums(patsSinFrec))
agrup = list()
for(i in 1:length(scoreUniq)){
print(which(patsSinFrec[,ncol(patsSinFrec)] == scoreUniq[i]))
agrup = append(agrup,list(which(patsSinFrec[,ncol(patsSinFrec)] == scoreUniq[i])))
}
for(i in 1:length(agrup)){
inds = agrup[[i]]
n = length(inds)
subMat = pats[inds,][,-ncol(pats)]
matB = matrix(rep(b.ini,n),nrow=n,byrow = T)
print((matB * subMat))
}
for(i in 1:length(agrup)){
inds = agrup[[i]]
n = length(inds)
subMat = pats[inds,][,-ncol(pats)]
matB = matrix(rep(b.ini,n),nrow=n,byrow = T)
prod = (matB * subMat)
expo = exp(rowSums(prod))
sum(expo)
}
gammaR = rep(0,length(agrup))
for(i in 1:length(agrup)){
inds = agrup[[i]]
n = length(inds)
subMat = pats[inds,][,-ncol(pats)]
matB = matrix(rep(b.ini,n),nrow=n,byrow = T)
prod = (matB * subMat)
expo = exp(rowSums(prod))
gammaR[i] = sum(expo)
}
gammaR
frecScore = rep(0,length(scoreUniq))
for(i in 1:length(scoreUniq)){
print(which(patsSinFrec[,ncol(patsSinFrec)] == scoreUniq[i]))
agrup = append(agrup,list(which(patsSinFrec[,ncol(patsSinFrec)] == scoreUniq[i])))
frecScore[i] = length(which(rowSums(data) == scoreUniq[i]))
}
agrup = list()
frecScore = rep(0,length(scoreUniq))
for(i in 1:length(scoreUniq)){
agrup = append(agrup,list(which(patsSinFrec[,ncol(patsSinFrec)] == scoreUniq[i])))
frecScore[i] = length(which(rowSums(data) == scoreUniq[i]))
}
frecScore
sum(frecScore)
gammaR
frecScore
gammaR ^ frecScore
prod(gammaR ^ frecScore)
