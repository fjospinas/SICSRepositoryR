}
secante(f = ceroTheta,x1 = 0,x2 = 1,rv = rv[2],b = ini.and[,2])
secante = function(f,x1,x2,eps = 10^(-5),num = 1000,...){
while (abs(x1 - x2) > eps) {
print(abs(x1-x2))
print("f")
print(f(x2,rv,b))
print("rv")
print(rv)
c = x2 - f(x2,rv,b) * (x2 - x1)/(f(x2,rv,b) - f(x1,rv,b))
x1 = x2
x2 = c
}
x2
}
secante(f = ceroTheta,x1 = 0,x2 = 1,rv = rv[2],b = ini.and[,2])
secante = function(f,x1,x2,eps = 10^(-5),num = 1000,...){
while (abs(x1 - x2) > eps) {
print(abs(x1-x2))
print("f")
print(f(x2,rv,b))
print("rv")
print(rv)
print("b")
print(b)
c = x2 - f(x2,rv,b) * (x2 - x1)/(f(x2,rv,b) - f(x1,rv,b))
x1 = x2
x2 = c
}
x2
}
secante(f = ceroTheta,x1 = 0,x2 = 1,rv = rv[2],b = ini.and[,2])
ceroTheta = function(theta,xvpunto,b){
sum(exp(theta - b) / (1-exp(theta - b))) - xvpunto
}
ceroTheta(2.5,xvpunto = rv[2],b = ini.and[,2])
secante = function(f,x1,x2,eps = 10^(-5),num = 1000,...){
while (abs(x1 - x2) > eps) {
print(abs(x1-x2))
print("f")
print(f(x2,rv,b))
print("rv")
print(rv)
print("b")
print(b)
c = x2 - f(x2,rv,b) * (x2 - x1)/(f(x2,rv,b) - f(x1,rv,b))
x1 = x2
x2 = c
}
x2
}
secante(f = ceroTheta,x1 = 0,x2 = 1,rv = rv[2],b = ini.and[,2])
rm(xvpunto
)
xvp
secante = function(f,x1,x2,eps = 10^(-5),num = 1000,...){
while (abs(x1 - x2) > eps) {
print(abs(x1-x2))
print("f")
print(f(x2,rv,b))
print("rv")
print(rv)
print("b")
print(b)
c = x2 - f(x2,xvpunto,b) * (x2 - x1)/(f(x2,xvpunto,b) - f(x1,xvpunto,b))
x1 = x2
x2 = c
}
x2
}
secante(f = ceroTheta,x1 = 0,x2 = 1,xvpunto = rv[2],b = ini.and[,2])
secante = function(f,x1,x2,eps = 10^(-5),num = 1000,...){
while (abs(x1 - x2) > eps) {
print(abs(x1-x2))
print("f")
print(f(x2,xvpunto,b))
print("rv")
print(xvpunto)
print("b")
print(b)
c = x2 - f(x2,xvpunto,b) * (x2 - x1)/(f(x2,xvpunto,b) - f(x1,xvpunto,b))
x1 = x2
x2 = c
}
x2
}
secante(f = ceroTheta,x1 = 0,x2 = 1,xvpunto = rv[2],b = ini.and[,2])
secante(f = ceroTheta,x1 = 0,x2 = 1,xvpunto = rv[2],b = ini.and[,2])
ceroTheta = function(theta){
sum(exp(theta - b) / (1-exp(theta - b))) - xvpunto
}
ceroTheta(2.5,xvpunto = rv[2],b = ini.and[,2])
ceroTheta(2.5)
xvpunto = rv[2]
b = ini.and[,2]
rv
xpuntoi
ceroTheta = function(theta){
sum(exp(theta - b) / (1-exp(theta - b))) - xvpunto
}
ceroTheta(2.5)
secante = function(f,x1,x2,eps = 10^(-5),num = 1000,...){
while (abs(x1 - x2) > eps) {
print(abs(x1-x2))
print("f")
print(f(x2))
print("rv")
print(xvpunto)
print("b")
print(b)
c = x2 - f(x2) * (x2 - x1)/(f(x2) - f(x1))
x1 = x2
x2 = c
}
x2
}
secante(f = ceroTheta,x1 = 0,x2 = 1,xvpunto = rv[2],b = ini.and[,2])
secante = function(f,x1,x2,eps = 10^(-5),num = 1000,...){
while (abs(x1 - x2) > eps) {
print(abs(x1-x2))
print("f")
print(f(x2))
c = x2 - f(x2) * (x2 - x1)/(f(x2) - f(x1))
x1 = x2
x2 = c
}
x2
}
secante(f = ceroTheta,x1 = 0,x2 = 1,xvpunto = rv[2],b = ini.and[,2])
secante = function(f,x1,x2,eps = 10^(-5),num = 1000,...){
while (abs(x1 - x2) > eps) {
print("Abs")
print(abs(x1-x2))
print("f")
print(f(x2))
c = x2 - f(x2) * (x2 - x1)/(f(x2) - f(x1))
x1 = x2
x2 = c
}
x2
}
secante(f = ceroTheta,x1 = 0,x2 = 1,xvpunto = rv[2],b = ini.and[,2])
secante = function(f,x1,x2,eps = 10^(-5),num = 1000,...){
while (abs(x1 - x2) > eps) {
print("Abs")
print(abs(x1-x2))
print("f")
print(f(x2))
print("x2")
print(x2)
c = x2 - f(x2) * (x2 - x1)/(f(x2) - f(x1))
x1 = x2
x2 = c
}
x2
}
secante(f = ceroTheta,x1 = 0,x2 = 1,xvpunto = rv[2],b = ini.and[,2])
secante = function(f,x1,x2,eps = 10^(-5),num = 1000,...){
while (abs(x1 - x2) > eps) {
print("Abs")
print(abs(x1-x2))
print("f")
print(f(x2))
print("x2")
print(x2)
c = x2 - f(x2) * (x2 - x1)/(f(x2) - f(x1))
x1 = x2
x2 = c
}
x2
}
secante(f = ceroTheta,x1 = -3,x2 = -2,xvpunto = rv[2],b = ini.and[,2])
sal =secante(f = ceroTheta,x1 = -3,x2 = -2,xvpunto = rv[2],b = ini.and[,2])
sal
ceroTheta(-3.337876)
sal =secante(f = ceroTheta,x1 = -2,x2 = 0,xvpunto = rv[2],b = ini.and[,2])
sal =secante(f = ceroTheta,x1 = -2,x2 = 0,xvpunto = rv[2],b = ini.and[,2])
fix(nlm)
?.External2
?nlm
data(LSAT7)
LSAT7 = as.matrix(LSAT7)
datos = expand.table(LSAT7)
inicio = Sys.time()
est = estimacion.Newton(datos)
Sys.time() - inicio
rm(list = ls(all = TRUE))
library(mirt)
library(Matrix)
library(numDeriv)
#-fopenmp
setwd("/home/mirt/Git/GrupoSICS/dev/SICSRepositoryR/")
system("PKG_CPPFLAGS=`Rscript -e 'Rcpp:::CxxFlags()'` PKG_LIBS=`Rscript -e 'Rcpp:::LdFlags()'` R CMD SHLIB  pasoe3.cpp")
system("PKG_CPPFLAGS=`Rscript -e 'Rcpp:::CxxFlags()'` PKG_LIBS=`Rscript -e 'Rcpp:::LdFlags()'` R CMD SHLIB  pasom3.cpp")
dyn.load("pasoe3.so")
dyn.load("pasom3.so")
###########
# PRUEBAS #
###########
D = 1
##################################################
# 3.Funcion para inicializar valores con Andrade #
##################################################
start.andrade = function(datos){
I = ncol(datos)
P = nrow(datos)
m = 5
#scores
T = apply(datos,1,sum)
#correlacion biserial
corr.bis = rep(NA,I)
for(i in 1:I){
corr.bis[i]  = cor(datos[,i],T,method="pearson")
}
#a inicial
a.ini = sqrt(corr.bis^2/(1-(corr.bis^2)))
#proporcion de aciertos
pi = as.vector(apply(datos,2,sum) / P)
#a inicial
b.ini = -(qnorm(pi) / corr.bis)
#b inicial
c.ini = 1 / rep(m,I)
ini.andrade = matrix(c(a.ini,b.ini,c.ini),ncol=3)
colnames(ini.andrade) = c("a","b","c")
ini.andrade
}
#función de puntos de cuadratura y pesos
library(statmod)
Cuad = gauss.quad(n=41,"hermite")
pt.cuad = Cuad[[1]] * sqrt(2)
pt.cuad = - (pt.cuad)
#pt.cuad
w.cuad = Cuad[[2]]  /  sqrt(pi)
pt.cuad = read.table("/home/mirt/Trabajo IRT/Algoritmo SICS/PWcuad.csv",dec=".",sep = " ",header = T)
w.cuad = pt.cuad[,2]
pt.cuad = pt.cuad[,1]
#Valores Iniciales Andrade
#and = t(start.andrade(datos))
#and[2,] = -and[2,] * and[1,]
#and[3,] = qlogis(and[3,])
#valores iniciales MIRT
inicio.mirt = function(datos){
ini.mirt = mirt(data=datos,model=1,itemtype="3PL",pars="values")
ini.mirt = ini.mirt$value
ini.mirt = ini.mirt[1:(length(ini.mirt) -2)]
ini.mirt = t(matrix(ini.mirt,ncol=4,byrow=T)[,c(1,2,3)])
ini.mirt[3,] = qlogis(ini.mirt[3,])
and = ini.mirt
and
}
patrones = function(datos){
items = ncol(datos)
comprim = apply(datos,MARGIN=1,FUN=paste,collapse="/")
freq = table(comprim)
pats = names(freq)
freq = as.vector(freq)
pats = as.numeric(unlist(lapply(pats,FUN=strsplit,split="/")))
pats = matrix(pats,ncol=items,byrow=T)
pats = cbind(pats,freq)
pats
}
#Probabilidad
gg = function(a,d, cp,  theta){
exp(cp)/(1+exp(cp))+ (1-(exp(cp)/(1+exp(cp))))*(1 + exp(-D*(a*theta+ d)))^(-1)
}
#Log verosimilitud
LL = function(zita.vec,R,fvec,pt.cuad,nitems){
suma = 0
for(k in 1:41){
for(i in 1:nitems){
rki = R[k,i]
fki = fvec[k]
a = zita.vec[i]
d = zita.vec[nitems + i]
c = zita.vec[2*nitems + i]
pki = gg(a=a,d=d,cp=c,theta=pt.cuad[k])
qki = 1 - pki
suma = suma + (rki*log(pki)+(fki-rki)*
log(qki))
}
}
-suma
}
LL2 = function(zita.vec,R,fvec,pt.cuad,nitems,and){
.Call("Loglik",zita.vec,R,fvec,pt.cuad)
}
gradLoglik = function(zita.vec,R,fvec,pt.cuad,nitems,and){
.Call("grad",zita.vec,R,fvec,pt.cuad)
}
inicio = Sys.time()
###################
# Algoritmos SICS #
###################
estimacion.Newton = function(datos){
and = inicio.mirt(datos)
and.copia = and
pats = patrones(datos)
npats = nrow(pats)
nitems = ncol(pats) - 1
zita.ant = zita = and
seguir = TRUE
mm = 0
contadorNear = 0
while(seguir){
inicio.ciclo = Sys.time()
mm = mm +1
##########
# Paso E #
##########
#inicioE = Sys.time()
RyF=.Call("calculoRF2",and,pt.cuad,w.cuad,pats)
#te = Sys.time() - inicioE
#print("*********Tiempo E")
#print(te)
R = RyF$R
fvec = RyF$fvec
##########
# Paso M #
##########
print("Entra a optim")
zita.vec = as.vector(t(zita))
#opt = optim(par=zita.vec,fn=LL,method="BFGS",R=R,fvec=fvec,pt.cuad=pt.cuad,nitems = nitems,control=list(maxit=10))
opt = optim(par=zita.vec,fn=LL2,gr=gradLoglik,method= "BFGS",R=R,fvec=fvec,pt.cuad=pt.cuad,nitems=nitems,and=and,control=list(maxit=20),hessian = T)
#opt = optim(par=zita.vec,fn=LL2,method= "L-BFGS-B",R=R,fvec=fvec,pt.cuad=pt.cuad,nitems=nitems,and=and,control=list(maxit=10))
#,lower = c(rep(-10,10),rep(-40,10),rep(-600,10)),upper = c(rep(10,10),rep(40,10),rep(600,10)))
#opt = vmmin(fr=LL,x=zita.vec,R=R,fvec=fvec,pt.cuad=pt.cuad,nitems = nitems)
contadorNear = contadorNear + 1
zita = matrix(opt$par,ncol=nitems,byrow=T)
hess = opt$hessian
zita[1,] = ifelse(abs(zita[1,]) > 10, and[1,], zita[1,])
zita[2,] = ifelse(abs(zita[2,]) > 40, and[2,], zita[2,])
zita[3,] = ifelse(abs(zita[3,]) > 600, and[3,], zita[3,])
##Imprime salidas
#print(mean(abs((zita - zita.ant)/zita.ant)))
print(paste("Fin ciclo: ", mm, " Convergencia: ", max(abs((zita - zita.ant)))," Tiempo Ciclo: ",Sys.time() - inicio.ciclo))
if(max(abs((zita - zita.ant))) < 10^(-3)){seguir = FALSE}
and = zita.ant = zita
if(mm > 1000){
print(paste("El algoritmo superó los ",mm - 1," ciclos",sep=""))
break()
#stop(paste("El algoritmo superó los ",mm - 1," ciclos",sep=""))
}
} #fin while
zita[3,] = plogis(zita[3,])
zita = t(zita)
list(zita=zita,contadorNear=contadorNear,ciclos = mm,pats = pats,hess = hess)
}
gcc = NULL
#sink("/home/mirt/Trabajo IRT/Algoritmo SICS/SalidaAUX.txt")
data(LSAT7)
LSAT7 = as.matrix(LSAT7)
datos = expand.table(LSAT7)
#datos = read.table("file:///home/mirt/ValidaciónTodoElAlgoritmo/Datasets/Test_10_6_1000.csv",sep=" ",header=T)
#datos = read.table("file:///home/mirt/ValidaciónTodoElAlgoritmo/Datasets/Test_10_2_1000.csv",sep=" ",header=T)
#datos = read.table("file:///home/mirt/ValidaciónTodoElAlgoritmo/Datasets/Test_10_10_2000.csv",sep=" ",header=T)
#datos = read.table("file:///home/mirt/ValidaciónTodoElAlgoritmo/Datasets/Test_100_2_10000.csv",sep=" ",header=T)
datos = read.table("file:///home/mirt/Validaciones_Modelos_Principales/3PL/Datasets/Test_10_1_1000.csv",sep=" ",header=T)
inicio = Sys.time()
est = estimacion.Newton(datos)
Sys.time() - inicio
#sink()
ggpat = function(pat,zita,nitems,cuad){
p = rep(0,nitems)
for(i in 1:nitems){
p[i] = gg(a = zita[i,1],d = zita[i,2],cp = qlogis(zita[i,3]),theta = cuad)
if(pat[i] == 0){
p[i] = 1 - p[i]
}
}
prod(p)
}
pats = est$pats
npats = nrow(est$pats)
nitems = ncol(est$pats) -1
#EAP
thetaEst3 = rep(0,npats)
for(j in 1:npats){
sumNum = 0
sumDen = 0
for(k in 1:41){
pat = pats[j,][1:nitems]
sumNum = sumNum + (pt.cuad[k] * w.cuad[k] * ggpat(pat = pat,zita = est$zita,nitems = nitems,cuad = pt.cuad[k]))
sumDen = sumDen + (w.cuad[k] * ggpat(pat = pat,zita = est$zita,nitems = nitems,cuad = pt.cuad[k]))
}
thetaEst3[j] = sumNum / sumDen
}
#Comparaciones con MIrt
pats2 = pats
pats2 = cbind(pats2,thetaEst3)
pats2
thetaEstMirt = fscores(fit)
ncol(thetaEstMirt)
nrow(thetaEstMirt)
nrow(pats2)
max(thetaEstMirt[,11] - pats2[,12])
mean(thetaEstMirt[,11] - pats2[,12])
#--------------------------Tercer método-------------------------------------------------
#Método MAP
#A la matriz de patrones le quita la columna frecuencia y añade una columna de ceros a modo de valores iniciales
patsTheta = cbind(est$pats[,-ncol(est$pats)],rep(0,nrow(est$pats)))
patsTheta
logL = function(theta,pat,zita,nitems){
probPat = log(ggpat(pat,zita,nitems,theta)) - ((theta^2)/2)
-probPat
}
#Uso de la función nlp para oprimizar funciones de R -> R
#No se puede usar optim debido a que optimiza funciones de R^p -> R
#Revisar implemetnacion de nlm del libro:
#Numerical Methods for Unconstrained Optimization and Nonlinear Equations
MAP = function(patsTheta,zita,nitems){
pat = patsTheta[1:nitems]
theta = patsTheta[nitems+1]
opt = nlm(f = logL,p=theta,pat=pat,zita=zita,nitems=nitems)
opt$estimate
}
#Apply para cada uno de los patrones
scoresSics = apply(patsTheta,1,FUN = MAP,zita = est$zita,nitems =10)
scoresMirt = fscores(fit)
#Comparaciones con MIRT
scoresMirt[,12] - scoresSics
mean(scoresMirt[,12] - scoresSics)
max(scoresMirt[,12] - scoresSics)
thetas = pats2[,12]
thetas
thetas
#Item.fit de SICS
item.fit.sics = function(pats,zita,theta,G = 10,FUN = median,p.val.sim = FALSE,boot.num = 100){
frec = pats[,ncol(pats)]
nitems = nrow(zita)
patsSinFrec = pats[,-ncol(pats)]
groups = quantile(theta,seq(0, 1, length.out = G + 1))
groups[1] = groups[1] - 0.1
groups[G + 1] = groups[G + 1] + 0.1
groups.ind = findInterval(theta,groups)
groups.ind = factor(groups.ind, levels = unique(groups.ind))
thetaG = tapply(rep(theta, frec), rep(groups.ind, frec), FUN = FUN)
pr = matrix(NA,ncol = nitems,nrow = G)
for(i in 1:G){
for(j in 1:nitems){
pr[i,j] = gg(a = zita[j,1],d = zita[j,2],cp = qlogis(zita[j,3]),theta = thetaG[i])
}
}
Nj = as.vector(tapply(frec, groups.ind, sum))
Obs = rowsum(frec * patsSinFrec, groups.ind, reorder = FALSE)/rep(Nj,nitems)
chi.square = Nj * (Obs - pr)^2/(pr * (1 - pr))
Tobs = colSums(chi.square, na.rm = TRUE)
df = G - 3
pvals <- pchisq(Tobs, df = df, lower.tail = FALSE)
salida = matrix(c(Tobs,pvals),ncol= 2)
salida
}
item.fit.sics(pats,est$zita,thetas,G=5)
mirt(datos,model = 1,itemtype = "3PL")
fit=mirt(datos,model = 1,itemtype = "3PL")
itemfit(fit)
item.fit.sics(pats,est$zita,thetas,G=5)
?itemfit
itemfit(fit,Zh = T,X2 = T)
ncol(datos)
fix(itemfit)
1000 / 150
npats
npats
item.fit.sics(pats,est$zita,thetas,G=6)
item.fit.sics(pats,est$zita,thetas,G=20)
item.fit.sics(pats,est$zita,thetas,G=7)
item.fit.sics(pats,est$zita,thetas,G=8)
item.fit.sics(pats,est$zita,thetas,G=9)
item.fit.sics(pats,est$zita,thetas,G=10)
a <- matrix(rlnorm(20, meanlog=0, sdlog = .1),ncol=1)
d <- matrix(rnorm(20),ncol=1)
items <- rep('dich', 20)
data <- simdata(a,d, 2000, items)
x <- mirt(data, 1)
raschfit <- mirt(data, 1, itemtype='Rasch')
fit <- itemfit(x)
fit
itemfit(x, empirical.plot = 1) #empirical item plot
2000/150
itemfit(x, empirical.plot = 1, empirical.CI = .99) #empirical item plot with 99% CI's
itemfit(raschfit, method = 'ML') #infit and outfit stats
Theta <- fscores(raschfit, method = 'ML', full.scores=TRUE, scores.only=TRUE)
itemfit(raschfit, Theta=Theta)
#' #same as above, but inputting ML estimates instead
Theta <- fscores(raschfit, method = 'ML', full.scores=TRUE, scores.only=TRUE)
itemfit(raschfit, Theta=Theta)
#'
#' #similar example to Kang and Chen 2007
a <- matrix(c(.8,.4,.7, .8, .4, .7, 1, 1, 1, 1))
d <- matrix(rep(c(2.0,0.0,-1,-1.5),10), ncol=4, byrow=TRUE)
dat <- simdata(a,d,2000, itemtype = rep('graded', 10)) - 1
head(dat)
mod <- mirt(dat, 1)
itemfit(mod)
mod2 <- mirt(dat, 1, 'Rasch')
itemfit(mod2)
tables <- itemfit(mod, S_X2.tables = TRUE)
tables$O[[1]]
tables$E[[1]]
mirtCluster(4)
mirtCluster(2)
fit <- itemfit(x,group.size = 100)
a <- matrix(rlnorm(20, meanlog=0, sdlog = .1),ncol=1)
d <- matrix(rnorm(20),ncol=1)
items <- rep('dich', 20)
data <- simdata(a,d, 2000, items)
x <- mirt(data, 1)
raschfit <- mirt(data, 1, itemtype='Rasch')
fit <- itemfit(x,group.size = 100)
fit
fit <- itemfit(x,group.size = 200)
fit
