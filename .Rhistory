muestra.tam = as.integer(N * 0.1) + 1
if(muestra.tam < 1000){
muestra.tam = 1000
}else if(muestra.tam > 10000){
muestra.tam = 10000
}
score = apply(datos,1,sum)
freq = unique(score)
scores.ind = lapply(freq,FUN= function(x){list(x,which(score == x))})
muestra.scores.ind = lapply(scores.ind,FUN = function(x){sample(as.vector(x[[2]]),size = (as.integer(length(x[[2]]))*muestra.tam/N)+1,replace=F)})
muestra.inds = sample(unlist(muestra.scores.ind),size=muestra.tam,replace=F)
salida=datos[muestra.inds,]
salida
}
#valores iniciales vía muestreo
val.ini = function(X,muestreo = T){
muestra <- if(muestreo && nrow(X) > 1000) selec.muestra(X) else X
mu <<- muestra
p = ncol(muestra)
scores = apply(muestra,1,sum)
thetas = (scores - mean(scores)) / sd(scores)
misThetas <<- thetas
thetas = cbind(rep(1,length(thetas)),thetas)
coefs <- matrix(0, p, 2)
for(i in 1:p){
fm <<- glm.fit(thetas,muestra[,i],family = binomial(link = "logit"))
coefs[i,] = fm$coefficients
}
coefs2 = matrix(c(coefs[,2],-coefs[,1]/coefs[,2]),ncol=2)
c = unlist(lapply(1:p,FUN = function(i){mean(thetas[,2] < coefs2[i,2] & ifelse(muestra[,i],T,F))}))
cbind(coefs2,c)
}
##################################################
# 3.Funcion para inicializar valores con Andrade #
##################################################
start.andrade = function(datos){
I = ncol(datos)
P = nrow(datos)
m = 5
#scores
T = apply(datos,1,sum)
#correlacion biserial
corr.bis = rep(NA,I)
for(i in 1:I){
corr.bis[i]  = cor(datos[,i],T,method="pearson")
}
#a inicial
a.ini = sqrt(corr.bis^2/(1-(corr.bis^2)))
#proporcion de aciertos
pi = as.vector(apply(datos,2,sum) / P)
#a inicial
b.ini = -(qnorm(pi) / corr.bis)
#b inicial
c.ini = 1 / rep(m,I)
ini.andrade = matrix(c(a.ini,b.ini,c.ini),ncol=3)
colnames(ini.andrade) = c("a","b","c")
ini.andrade
}
#valores iniciales MIRT
inicio.mirt = function(datos){
ini.mirt = mirt(data=datos,model=1,itemtype="3PL",pars="values")
ini.mirt = ini.mirt$value
ini.mirt = ini.mirt[1:(length(ini.mirt) -2)]
ini.mirt = matrix(ini.mirt,ncol=4,byrow = T)
ini.mirt[,2] = - ini.mirt[,2] / ini.mirt[,1]
ini.mirt[,-4]
}
#Directorios de trabajo
rutaDataset = "/home/mirt/Validaciones_Modelos_Principales/3PL/Datasets/"
rutaTiempos = "/home/mirt/Trabajo IRT/Evaluación puntos iniciales/Versión para nuevo esquema de datasets/Tiempo estimación/"
items = c(10,20)
inds = c(1000,2000)
replicas = 4
#items = c(50,100)
#inds = c(5000,10000)
#replicas = 40
for(j in 1:length(inds)){
for(i in 1:length(items)){
matTiempoMirt = matrix(0,nrow = replicas,ncol = 3)
for(k in 1:replicas){
print(paste("-----------------Ciclo: ",k,"-----------------",sep = ""))
#carga dataset
datos = read.table(file = paste(rutaDataset,"Test_",items[i],"_",k,"_",inds[j],".csv",sep = ""),header = T,sep=)
datos = as.matrix(datos)
#Calcula valores iniciales de mirt
inicioMirt = mirt(data = datos,model = 1,itemtype = "3PL",pars = "values")
#Calcula valores iniciales SICS
ini.sics = val.ini(datos,muestreo = T)
ini.sics[,2] = - ini.sics[,2] * ini.sics[,1]
ini.mirt = modifIniMirt(ini.mirt = inicioMirt,ini.alt = ini.sics)
#Corre estimación con valores iniciales SICS
inicio = Sys.time()
fit = mirt(data = datos,model = 1,itemtype = "3PL",pars = ini.mirt,
technical = list(NCYCLES = 2000),TOL = 10^(-3))
tiempoSics = Sys.time() - inicio
#Calcula valores iniciales de andrade
ini.and = start.andrade(datos)
ini.and[,2] = - ini.and[,2] * ini.and[,1]
ini.mirt = modifIniMirt(ini.mirt = inicioMirt,ini.alt = ini.and)
#Corre estimación con valores iniciales de andrade
inicio = Sys.time()
fit = mirt(data = datos,model = 1,itemtype = "3PL",pars = ini.mirt,
technical = list(NCYCLES = 2000),TOL = 10^(-3))
tiempoAnd = Sys.time() - inicio
#Corre estimación con valores iniciales de mirt
inicio = Sys.time()
fit = mirt(data = datos,model = 1,itemtype = "3PL",pars = inicioMirt,
technical = list(NCYCLES = 2000),TOL = 10^(-3))
tiempoMirt = Sys.time() - inicio
matTiempoMirt[k,] = c(tiempoAnd,tiempoMirt,tiempoSics)
}
colnames(matTiempoMirt) = c("Tiempo Sics","Tiempo And","Tiempo Mirt")
}
print(paste(rutaTiempos,"Test_",items[i],"_",inds[j],".csv",sep = ""))
write.table(file = paste(rutaTiempos,"Test_",items[i],"_",inds[j],".csv",sep = ""),x = matTiempoMirt,row.names = F)
}
matTiempoMirt
colMeans(matTiempoMirt)
library(mirt)
modifIniMirt = function(ini.mirt,ini.alt){
ini.alt[,2] = - ini.alt[,2] * ini.alt[,1]
ini.alt = cbind(ini.alt,1)
ini.alt = as.vector(t(ini.alt))
ini.alt = c(ini.alt,c(0,1))
ini.mirt[,6] = ini.alt
ini.mirt
}
selec.muestra = function(datos){
I = ncol(datos)
N = nrow(datos)
muestra.tam = as.integer(N * 0.1) + 1
if(muestra.tam < 1000){
muestra.tam = 1000
}else if(muestra.tam > 10000){
muestra.tam = 10000
}
score = apply(datos,1,sum)
freq = unique(score)
scores.ind = lapply(freq,FUN= function(x){list(x,which(score == x))})
muestra.scores.ind = lapply(scores.ind,FUN = function(x){sample(as.vector(x[[2]]),size = (as.integer(length(x[[2]]))*muestra.tam/N)+1,replace=F)})
muestra.inds = sample(unlist(muestra.scores.ind),size=muestra.tam,replace=F)
salida=datos[muestra.inds,]
salida
}
#valores iniciales vía muestreo
val.ini = function(X,muestreo = T){
muestra <- if(muestreo && nrow(X) > 1000) selec.muestra(X) else X
mu <<- muestra
p = ncol(muestra)
scores = apply(muestra,1,sum)
thetas = (scores - mean(scores)) / sd(scores)
misThetas <<- thetas
thetas = cbind(rep(1,length(thetas)),thetas)
coefs <- matrix(0, p, 2)
for(i in 1:p){
fm <<- glm.fit(thetas,muestra[,i],family = binomial(link = "logit"))
coefs[i,] = fm$coefficients
}
coefs2 = matrix(c(coefs[,2],-coefs[,1]/coefs[,2]),ncol=2)
c = unlist(lapply(1:p,FUN = function(i){mean(thetas[,2] < coefs2[i,2] & ifelse(muestra[,i],T,F))}))
cbind(coefs2,c)
}
##################################################
# 3.Funcion para inicializar valores con Andrade #
##################################################
start.andrade = function(datos){
I = ncol(datos)
P = nrow(datos)
m = 5
#scores
T = apply(datos,1,sum)
#correlacion biserial
corr.bis = rep(NA,I)
for(i in 1:I){
corr.bis[i]  = cor(datos[,i],T,method="pearson")
}
#a inicial
a.ini = sqrt(corr.bis^2/(1-(corr.bis^2)))
#proporcion de aciertos
pi = as.vector(apply(datos,2,sum) / P)
#a inicial
b.ini = -(qnorm(pi) / corr.bis)
#b inicial
c.ini = 1 / rep(m,I)
ini.andrade = matrix(c(a.ini,b.ini,c.ini),ncol=3)
colnames(ini.andrade) = c("a","b","c")
ini.andrade
}
#valores iniciales MIRT
inicio.mirt = function(datos){
ini.mirt = mirt(data=datos,model=1,itemtype="3PL",pars="values")
ini.mirt = ini.mirt$value
ini.mirt = ini.mirt[1:(length(ini.mirt) -2)]
ini.mirt = matrix(ini.mirt,ncol=4,byrow = T)
ini.mirt[,2] = - ini.mirt[,2] / ini.mirt[,1]
ini.mirt[,-4]
}
#Directorios de trabajo
rutaDataset = "/home/mirt/Validaciones_Modelos_Principales/3PL/Datasets/"
rutaTiempos = "/home/mirt/Trabajo IRT/Evaluación puntos iniciales/Versión para nuevo esquema de datasets/Tiempo estimación/"
items = c(10,20)
inds = c(1000,2000)
replicas = 4
#items = c(50,100)
#inds = c(5000,10000)
#replicas = 40
for(j in 1:length(inds)){
for(i in 1:length(items)){
matTiempoMirt = matrix(0,nrow = replicas,ncol = 3)
for(k in 1:replicas){
print(paste("-----------------Ciclo: ",k,"-----------------",sep = ""))
#carga dataset
datos = read.table(file = paste(rutaDataset,"Test_",items[i],"_",k,"_",inds[j],".csv",sep = ""),header = T,sep=)
datos = as.matrix(datos)
#Calcula valores iniciales de mirt
inicioMirt = mirt(data = datos,model = 1,itemtype = "3PL",pars = "values")
#Calcula valores iniciales SICS
ini.sics = val.ini(datos,muestreo = T)
ini.sics[,2] = - ini.sics[,2] * ini.sics[,1]
ini.mirt = modifIniMirt(ini.mirt = inicioMirt,ini.alt = ini.sics)
#Corre estimación con valores iniciales SICS
inicio = Sys.time()
fit = mirt(data = datos,model = 1,itemtype = "3PL",pars = ini.mirt,
technical = list(NCYCLES = 2000),TOL = 10^(-3))
tiempoSics = Sys.time() - inicio
#Calcula valores iniciales de andrade
ini.and = start.andrade(datos)
ini.and[,2] = - ini.and[,2] * ini.and[,1]
ini.mirt = modifIniMirt(ini.mirt = inicioMirt,ini.alt = ini.and)
#Corre estimación con valores iniciales de andrade
inicio = Sys.time()
fit = mirt(data = datos,model = 1,itemtype = "3PL",pars = ini.mirt,
technical = list(NCYCLES = 2000),TOL = 10^(-3))
tiempoAnd = Sys.time() - inicio
#Corre estimación con valores iniciales de mirt
inicio = Sys.time()
fit = mirt(data = datos,model = 1,itemtype = "3PL",pars = inicioMirt,
technical = list(NCYCLES = 2000),TOL = 10^(-3))
tiempoMirt = Sys.time() - inicio
matTiempoMirt[k,] = c(tiempoAnd,tiempoMirt,tiempoSics)
}
colnames(matTiempoMirt) = c("Tiempo Sics","Tiempo And","Tiempo Mirt")
print(paste(rutaTiempos,"Test_",items[i],"_",inds[j],".csv",sep = ""))
write.table(file = paste(rutaTiempos,"Test_",items[i],"_",inds[j],".csv",sep = ""),x = matTiempoMirt,row.names = F)
}
}
matTiempoMirt
colMeans(matTiempoMirt)
6%%3
6%%4
library(mirt)
modifIniMirt = function(ini.mirt,ini.alt){
ini.alt[,2] = - ini.alt[,2] * ini.alt[,1]
ini.alt = cbind(ini.alt,1)
ini.alt = as.vector(t(ini.alt))
ini.alt = c(ini.alt,c(0,1))
ini.mirt[,6] = ini.alt
ini.mirt
}
selec.muestra = function(datos){
I = ncol(datos)
N = nrow(datos)
muestra.tam = as.integer(N * 0.1) + 1
if(muestra.tam < 1000){
muestra.tam = 1000
}else if(muestra.tam > 10000){
muestra.tam = 10000
}
score = apply(datos,1,sum)
freq = unique(score)
scores.ind = lapply(freq,FUN= function(x){list(x,which(score == x))})
muestra.scores.ind = lapply(scores.ind,FUN = function(x){sample(as.vector(x[[2]]),size = (as.integer(length(x[[2]]))*muestra.tam/N)+1,replace=F)})
muestra.inds = sample(unlist(muestra.scores.ind),size=muestra.tam,replace=F)
salida=datos[muestra.inds,]
salida
}
#valores iniciales vía muestreo
val.ini = function(X,muestreo = T){
muestra <- if(muestreo && nrow(X) > 1000) selec.muestra(X) else X
mu <<- muestra
p = ncol(muestra)
scores = apply(muestra,1,sum)
thetas = (scores - mean(scores)) / sd(scores)
misThetas <<- thetas
thetas = cbind(rep(1,length(thetas)),thetas)
coefs <- matrix(0, p, 2)
for(i in 1:p){
fm <<- glm.fit(thetas,muestra[,i],family = binomial(link = "logit"))
coefs[i,] = fm$coefficients
}
coefs2 = matrix(c(coefs[,2],-coefs[,1]/coefs[,2]),ncol=2)
c = unlist(lapply(1:p,FUN = function(i){mean(thetas[,2] < coefs2[i,2] & ifelse(muestra[,i],T,F))}))
cbind(coefs2,c)
}
##################################################
# 3.Funcion para inicializar valores con Andrade #
##################################################
start.andrade = function(datos){
I = ncol(datos)
P = nrow(datos)
m = 5
#scores
T = apply(datos,1,sum)
#correlacion biserial
corr.bis = rep(NA,I)
for(i in 1:I){
corr.bis[i]  = cor(datos[,i],T,method="pearson")
}
#a inicial
a.ini = sqrt(corr.bis^2/(1-(corr.bis^2)))
#proporcion de aciertos
pi = as.vector(apply(datos,2,sum) / P)
#a inicial
b.ini = -(qnorm(pi) / corr.bis)
#b inicial
c.ini = 1 / rep(m,I)
ini.andrade = matrix(c(a.ini,b.ini,c.ini),ncol=3)
colnames(ini.andrade) = c("a","b","c")
ini.andrade
}
#valores iniciales MIRT
inicio.mirt = function(datos){
ini.mirt = mirt(data=datos,model=1,itemtype="3PL",pars="values")
ini.mirt = ini.mirt$value
ini.mirt = ini.mirt[1:(length(ini.mirt) -2)]
ini.mirt = matrix(ini.mirt,ncol=4,byrow = T)
ini.mirt[,2] = - ini.mirt[,2] / ini.mirt[,1]
ini.mirt[,-4]
}
#Directorios de trabajo
rutaDataset = "/home/mirt/Validaciones_Modelos_Principales/3PL/Datasets/"
rutaTiempos = "/home/mirt/Trabajo IRT/Evaluación puntos iniciales/Versión para nuevo esquema de datasets/Tiempo estimación/"
items = c(10,20)
inds = c(1000,2000)
replicas = 10
#items = c(50,100)
#inds = c(5000,10000)
#replicas = 40
for(j in 1:length(inds)){
for(i in 1:length(items)){
matTiempoMirt = matrix(0,nrow = replicas,ncol = 3)
for(k in 1:replicas){
if(k%%10 == 0){
print(paste("-----------------Ciclo: ",k,"-----------------",sep = ""))
}
#carga dataset
datos = read.table(file = paste(rutaDataset,"Test_",items[i],"_",k,"_",inds[j],".csv",sep = ""),header = T,sep=)
datos = as.matrix(datos)
#Calcula valores iniciales de mirt
inicioMirt = mirt(data = datos,model = 1,itemtype = "3PL",pars = "values")
#Calcula valores iniciales SICS
ini.sics = val.ini(datos,muestreo = T)
ini.sics[,2] = - ini.sics[,2] * ini.sics[,1]
ini.mirt = modifIniMirt(ini.mirt = inicioMirt,ini.alt = ini.sics)
#Corre estimación con valores iniciales SICS
inicio = Sys.time()
fit = mirt(data = datos,model = 1,itemtype = "3PL",pars = ini.mirt,
technical = list(NCYCLES = 2000),TOL = 10^(-3))
tiempoSics = Sys.time() - inicio
#Calcula valores iniciales de andrade
ini.and = start.andrade(datos)
ini.and[,2] = - ini.and[,2] * ini.and[,1]
ini.mirt = modifIniMirt(ini.mirt = inicioMirt,ini.alt = ini.and)
#Corre estimación con valores iniciales de andrade
inicio = Sys.time()
fit = mirt(data = datos,model = 1,itemtype = "3PL",pars = ini.mirt,
technical = list(NCYCLES = 2000),TOL = 10^(-3))
tiempoAnd = Sys.time() - inicio
#Corre estimación con valores iniciales de mirt
inicio = Sys.time()
fit = mirt(data = datos,model = 1,itemtype = "3PL",pars = inicioMirt,
technical = list(NCYCLES = 2000),TOL = 10^(-3))
tiempoMirt = Sys.time() - inicio
matTiempoMirt[k,] = c(tiempoAnd,tiempoMirt,tiempoSics)
}
colnames(matTiempoMirt) = c("Tiempo Sics","Tiempo And","Tiempo Mirt")
colMeans(matTiempoMirt)
write.table(file = paste(rutaTiempos,"Test_",items[i],"_",inds[j],".csv",sep = ""),x = matTiempoMirt,row.names = F)
}
}
library(mirt)
modifIniMirt = function(ini.mirt,ini.alt){
ini.alt[,2] = - ini.alt[,2] * ini.alt[,1]
ini.alt = cbind(ini.alt,1)
ini.alt = as.vector(t(ini.alt))
ini.alt = c(ini.alt,c(0,1))
ini.mirt[,6] = ini.alt
ini.mirt
}
selec.muestra = function(datos){
I = ncol(datos)
N = nrow(datos)
muestra.tam = as.integer(N * 0.1) + 1
if(muestra.tam < 1000){
muestra.tam = 1000
}else if(muestra.tam > 10000){
muestra.tam = 10000
}
score = apply(datos,1,sum)
freq = unique(score)
scores.ind = lapply(freq,FUN= function(x){list(x,which(score == x))})
muestra.scores.ind = lapply(scores.ind,FUN = function(x){sample(as.vector(x[[2]]),size = (as.integer(length(x[[2]]))*muestra.tam/N)+1,replace=F)})
muestra.inds = sample(unlist(muestra.scores.ind),size=muestra.tam,replace=F)
salida=datos[muestra.inds,]
salida
}
#valores iniciales vía muestreo
val.ini = function(X,muestreo = T){
muestra <- if(muestreo && nrow(X) > 1000) selec.muestra(X) else X
mu <<- muestra
p = ncol(muestra)
scores = apply(muestra,1,sum)
thetas = (scores - mean(scores)) / sd(scores)
misThetas <<- thetas
thetas = cbind(rep(1,length(thetas)),thetas)
coefs <- matrix(0, p, 2)
for(i in 1:p){
fm <<- glm.fit(thetas,muestra[,i],family = binomial(link = "logit"))
coefs[i,] = fm$coefficients
}
coefs2 = matrix(c(coefs[,2],-coefs[,1]/coefs[,2]),ncol=2)
c = unlist(lapply(1:p,FUN = function(i){mean(thetas[,2] < coefs2[i,2] & ifelse(muestra[,i],T,F))}))
cbind(coefs2,c)
}
##################################################
# 3.Funcion para inicializar valores con Andrade #
##################################################
start.andrade = function(datos){
I = ncol(datos)
P = nrow(datos)
m = 5
#scores
T = apply(datos,1,sum)
#correlacion biserial
corr.bis = rep(NA,I)
for(i in 1:I){
corr.bis[i]  = cor(datos[,i],T,method="pearson")
}
#a inicial
a.ini = sqrt(corr.bis^2/(1-(corr.bis^2)))
#proporcion de aciertos
pi = as.vector(apply(datos,2,sum) / P)
#a inicial
b.ini = -(qnorm(pi) / corr.bis)
#b inicial
c.ini = 1 / rep(m,I)
ini.andrade = matrix(c(a.ini,b.ini,c.ini),ncol=3)
colnames(ini.andrade) = c("a","b","c")
ini.andrade
}
#valores iniciales MIRT
inicio.mirt = function(datos){
ini.mirt = mirt(data=datos,model=1,itemtype="3PL",pars="values")
ini.mirt = ini.mirt$value
ini.mirt = ini.mirt[1:(length(ini.mirt) -2)]
ini.mirt = matrix(ini.mirt,ncol=4,byrow = T)
ini.mirt[,2] = - ini.mirt[,2] / ini.mirt[,1]
ini.mirt[,-4]
}
#Directorios de trabajo
rutaDataset = "/home/mirt/Validaciones_Modelos_Principales/3PL/Datasets/"
rutaTiempos = "/home/mirt/Trabajo IRT/Evaluación puntos iniciales/Versión para nuevo esquema de datasets/Tiempo estimación/"
items = c(10,20)
inds = c(1000,2000)
replicas = 10
#items = c(50,100)
#inds = c(5000,10000)
#replicas = 40
for(j in 1:length(inds)){
for(i in 1:length(items)){
matTiempoMirt = matrix(0,nrow = replicas,ncol = 3)
for(k in 1:replicas){
if(k%%10 == 0){
print(paste("-----------------Ciclo: ",k,"-----------------",sep = ""))
}
#carga dataset
datos = read.table(file = paste(rutaDataset,"Test_",items[i],"_",k,"_",inds[j],".csv",sep = ""),header = T,sep=)
datos = as.matrix(datos)
#Calcula valores iniciales de mirt
inicioMirt = mirt(data = datos,model = 1,itemtype = "3PL",pars = "values")
#Calcula valores iniciales SICS
ini.sics = val.ini(datos,muestreo = T)
ini.sics[,2] = - ini.sics[,2] * ini.sics[,1]
ini.mirt = modifIniMirt(ini.mirt = inicioMirt,ini.alt = ini.sics)
#Corre estimación con valores iniciales SICS
inicio = Sys.time()
fit = mirt(data = datos,model = 1,itemtype = "3PL",pars = ini.mirt,
technical = list(NCYCLES = 2000),TOL = 10^(-3))
tiempoSics = Sys.time() - inicio
#Calcula valores iniciales de andrade
ini.and = start.andrade(datos)
ini.and[,2] = - ini.and[,2] * ini.and[,1]
ini.mirt = modifIniMirt(ini.mirt = inicioMirt,ini.alt = ini.and)
#Corre estimación con valores iniciales de andrade
inicio = Sys.time()
fit = mirt(data = datos,model = 1,itemtype = "3PL",pars = ini.mirt,
technical = list(NCYCLES = 2000),TOL = 10^(-3))
tiempoAnd = Sys.time() - inicio
#Corre estimación con valores iniciales de mirt
inicio = Sys.time()
fit = mirt(data = datos,model = 1,itemtype = "3PL",pars = inicioMirt,
technical = list(NCYCLES = 2000),TOL = 10^(-3))
tiempoMirt = Sys.time() - inicio
matTiempoMirt[k,] = c(tiempoAnd,tiempoMirt,tiempoSics)
}
colnames(matTiempoMirt) = c("Tiempo Sics","Tiempo And","Tiempo Mirt")
print(colMeans(matTiempoMirt))
write.table(file = paste(rutaTiempos,"Test_",items[i],"_",inds[j],".csv",sep = ""),x = matTiempoMirt,row.names = F)
}
}
matTiempoMirt
colMeans(matTiempoMirt)
